索引是应用设计的一个重要方面，太多的索引，DML的性能就会受到影响，如果索引太少，又会影响查询的性能。要找到一个平衡点。

一、索引概述
  B*树索引：传统索引，所有数据库最常用的索引。类似于二叉树，能根据键提供一行或一个行集的快速访问，通常只需很少的读操作就能找到正确的行。
  位图索引：在一颗B*树中，通常索引条目和行之间存在一种一对一的关系，而对于位图索引，一个索引条目则使用一个位图同时指向多行，位图索引适用于高度重复而且通常只读的数据。
二、B*树索引
  叶子节点：B*树最底层的块成为叶子节点或叶子块，其中分别包含各个索引键以及一个rowid（指向所索引的行）；
  分支块：叶子节点之上的内部块称为分支块，这些节点用于在结构中实现导航。
  注意：索引的叶子节点实际上构成了一个双向链表。一旦发现要从叶子节点中的哪里开始，执行值的有序扫描（即索引的区间扫描）就会很容易。
  B*树的特点之一是：所有叶子块都应该在树的同一层上。这一层也称为索引的高度。说明所有从索引的根块到叶子块的遍历都会访问同样数目的块。
  索引是高度平衡的。大多数B*树索引的高度都是2或者3，即使索引中有百万行记录也是如此。
  
  1、索引键压缩
    压缩键索引的基本概念是，每个键条目分解为两部分，前缀和后缀。
  2、索引和表的存储机制
    索引按照索引键的顺序存储，索引会按键的有序顺序进行访问。
    索引指向的块则随机地存储在堆中，因此通过索引访问表时，会执行大量分散、随机的I/O。这种I/O可能很慢。
    索引的此种存储机制决定了索引的两种使用情况。记住，有索引并不代表更快的相应速度。
三、位图索引
  位图索引是这样一种结构，其中用一个索引键条目存储指向多行的指针；与B*树结构不同。在位图索引中，可能只有很少的索引条目，每个索引条目指向多行。
  Oracle为每个键值存储位图，使得每个位置表示底层表中的1个rowid，以后如果确实需要访问行时，可以利用rowid处理。
  这个例子应该使用位图索引:
  create bitmap index gender_idx on t(gender);
  create bitmap index location_idx on t(location);
  create bitmap index age_group_idx on t(age_group);
  exec dbms_stats.gather_table_stats( user, 'T', cascade=>true );

  select count(*)  from T
  where gender = 'M'   and location in ( 1, 10, 30 )
    and age_group = '41 and over';

  select *  from t
  where (   ( gender = 'M' and location = 20 )
        or ( gender = 'F' and location = 22 )) and age_group = '18 and under';
  在数据仓库或支持即席查询的大型报告系统中，能同时合理地使用尽可能多的索引确实非常有用。
  位图索引在读密集的环境中能很好地工作，但在写密集的环境则不行。
四、位图联结索引
  通常索引都是在一个表上创建索引，而且只使用这个表的列。位图联结索引允许使用另外某个表的列对一个给定表建立索引。实际上，这就允许对一个索引结构（而不是表本身）中的数据进行逆规范化。
  这是一个全新的概念：能从其他表对某个表的属性建立索引，而这可能会改变应用中实现数据模型的方式。
  位图联结索引确实有一个先决条件，必须联结到另外一个表中的主键或唯一键，否则会出现错误提示。
  位图索引增加很容易，而且通常比B*树索引快得多。
  如果是一个很大的环境，主要是只读操作，并且有大量即席查询，应用所需的可能正是一组位图索引。
五、基于函数的索引
  利用基于函数的索引，能够对计算得出的列建立索引，并且在查询中使用这些索引。
  1、使用基于函数的索引的主要原因：
    容易实现，并能立即提交一个值；
    可以加快现有应用的速度，而不用修改任何逻辑或查询。
  如果应用总是插入数据，而不经常查询，基于函数的索引可能并不适用。
六、应用域索引
  应用域索引在oracle中也称为可扩展索引。
  利用应用域索引，可以创建自己的索引结构，使之像oracle提供的索引一样工作。
  利用应用域索引，应用可以实现数据库中原本没有的一个新的索引类型。
  例子：oracle自己的文本索引。这个索引用于对大量的文本项提供关键字搜索
    Create index myindex on mytable(docs) 
    Indextype is crxsys.context;
  
    Select * from mytable 
    where contains(docs, ‘some words’ ) > 0;
七、常见问题
  1、视图能否使用索引？
    视图实际上一个存储查询，oracle会把查询中访问视图的有关文本代之以视图定义本身。视图只是为了方便最终用户或程序员，优化器还是会对基表使用查询。使用视图时，完全可以考虑使用为基表编写的查询中所能用的所有索引。对视图建立索引实际上就是对基表建立索引。
  2、NULL和索引能协作吗？
    B*树索引不会存储完全为NULL的条目，而位图和聚簇索引则不同，这个副作用可能会带来一些混淆。
    如果索引是一个惟一索引，则可能产生混淆，对于NULL条目，说明创建的惟一键并不惟一。
    事实上，在oracle中，惟一性对(null,null)与(null,null)并不相同，这是SQL标准要求的。
    应当考虑：每个惟一约束应该至少有一个确实惟一的not null列。
    只有当索引键中至少有一个列定义为not null时查询才会使用索引。
  3、外键是否应该加索引？
    一般而言，外键未加索引是导致死锁的最主要原因。
    如果有一个on delete cascade，而且没有对子表建索引，就会导致对子表执行一个全表扫描。这种扫描可能是不必要的，而且如果父表删除多行，对于删除的每一个父行，都会对子表执行一次全表扫描；
    从父表查询子表时，如果没有索引会使得查询变慢。
  4、何时不需要对外键加索引？
    未删除父表中的行；
    不论是有意还是无意，总之未更新父表的惟一主键值；
    不会从父表联结到子表，或者更一般的讲，外键列不支持子表的一个重要访问路径，而且应用在谓词中没有使用这些外键列从子表中选择数据。
    如果满足上述3个条件，就完全可以不必给外键加索引。
  5、神话：最有差别的元素应该在最前面
    按照各个列的差别大小来安排这些列在索引中的顺序并不会获得本质上的效率提升。但如果考虑压缩，可能倾向于将最没有选择性的列放在前面。













  

    

 
  
