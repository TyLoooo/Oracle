控制同时发生的多个数据请求是数据库必须完成的一项非常重要的任务。这也使得数据库变得非常复杂。

一、数据库支持多用户的总体目的
  1、数据完整性：某个用户对数据的任何变化不会影响其他用户的数据，而且需要保证返回给用户稳定的数据。这需要数据库内部机制来保证（如约束）；
  2、隔离：数据库必须允许在任何时候用户同其他用户隔离。
  3、串行化：上述两点带来了复杂性。解决该复杂性的一个办法就是将任何用户的整个工作分割成许多小片，称为事务。数据库必须保证事务是按照逻辑顺序产生的，必须实现所有事务的串行化（有点类似分时操作系统）。
二、事务
  事务(transaction)是数据库区别于文件系统的特性之一。
  1、数据库中引入事务的主要目的：事务会把数据库从一种一致状态转变为另一种一致状态。
    （1）在数据库中提交工作时，可以确保要么所有修改都已经保存，要么所有修改都不保存。
    （2）另外，事务还能保证实现了保护数据完整性的各种规则和检查。
  2、Oracle中的事务体现了所有必要的ACID特征
    （1）原子性(atomicity)：事务中的所有动作要么都发生，要么都不发生；
    （2）一致性(consistency)：事务将数据库从一种一致状态转变为下一种一致状态；
    （3）隔离性(isolation)：一个事务的影响在该事务提交前对其他事务都不可见；
    （4）持久性(durability)：事务一旦提交，其结果就是永久性的。
  3、事务控制语句
    （1）Oracle中不需要专门的语句来“开始事务”。隐含地，事务会在修改数据的第一条语句处开始。
    （2）可以使用set transaction或dbms_transac-tion包来显式地开始一个事务，但是这一步并不是必要的。
    （3）如果发出commit或rollback语句，就会显式地结束一个事务。
    （4）Oracle中可以为一个事务单独指定一个隔离级别。
    （5）一定要显式地使用commit或rollback来终止你的事务；否则，你使用的工具/环境就会从中挑一个来结束事务。
    （6）不要过份依赖这些隐式行为，因为将来这些行为可能会有改变。而且无法对事务做到明确的控制。
    （7）Oracle中的事务控制语句有：
        Commit;
        Rollback
        Savepoint
        Rollback to <savepoint>
        Set transaction
  4、事务控制语句-commit
    有两种形式：commit或commit work；
    Commit：结束事务，并使得已做的所有修改成为永久性的（持久保存）；
    Commit语句还有一些扩展用于分布式事务中。利用这些扩展，允许增加一些有意义的注释为commit加标签（对事务加标签），以及强制提交一个可疑的分布式事务。
  5、事务控制语句—rollback或rollback work
    回滚会结束事务，并撤销正在进行的所有未提交的修改。
    为此需要读取存储在回滚段/undo段中的信息，并把数据库块恢复到事务开始之前的状态。
  6、事务控制语句-savepoint
    savepoint允许在事务中创建一个标记点，一个事务可以有多个标记点。
    一般情况下，和rollback配合使用，用于在事务中的部分回滚。
      rollback to <savepoint>
    与savepoint语句配合使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。例如：
    Update ……
    Update ……
    Savepoint 
    Delete
    Rollback to savepoint
  7、原子性
    （1）语句原子性
      语句原子性指的是oracle保证了语句操作的原子性（要么全部成功，要么全部失败）。
      单条语句没有问题，容易理解，但如果该条语句存在约束，而且还涉及到其他的表、触发器等对象时，该怎么办呢？
        a、为了得到这种语句级原子性，oracle悄悄地在每个数据库调用外面包了一个savepoint。insert的实际处理如下：
          savepoint statement1；
            insert into t values（1）；
          if error then rollback to stetement1; 
      (2)过程原子性
        Oracle中将PL/SQL匿名块也当作是语句，也保证了过程的原子性。
        创建过程来处理插入操作：
          create or replace procedure p 
          AS
          Begin
            insert into t values(1);
          End;
          a、我们通过begin p; end;来调用p过程。
          b、Oracle把这个存储过程调用处理为一个原子语句。Oracle在外面包装了一个savepoint。
          c、由于p失败了，oracle将数据库恢复到调用这个存储过程之前的时间点。
        修改后的代码块：
          Begin
            savepoint sp;
            p;
          Exception
            when others then rollback to sp;
          End;
      （3）事务原子性
        事务，也是一组SQL语句作为一个工作单元一同执行，其总目标是把数据库从一种一致状态转变为另一种一致状态。
        数据完整性才是确定事务大小的根本；
        频繁地提交大量小事务比处理和提交一个大事务更快，也更高效。
        如果频繁提交，通常并不会更快。一般地，在一个SQL语句中完成工作几乎总是更快一些。
    8、用户完整性问题 
      多名用户同时读取相同的数据会造成完整性的三个基本问题：丢失更新、不可重复读、幻影读取。
      （1）丢失更新实际上是多个用户同时读取相同数据时，一个用户对数据的更新覆盖了另一个用户对该数据的更新。
      （2）不可重复的读取，在一个事务的不同时间点，获得的数据不一致。
      （3）幻影读取是当用户在自己的事务中读取数据时，读取了在事务期间别的用户新增的数据（事务开始时无此数据）。
    9、锁
      数据的相互作用决定了锁的两种类型：
        共享锁，有时称为读取锁；
        专用锁，有时称为写操作锁。
      （1）专用锁只允许单独用户对数据段进行访问，数据库无法为已经放置了共享锁的数据段发布一个专用锁。
        如果数据库在事务的中间，允许其他用户改变数据，结果既可能造成丢失更新，或者无法重复读取，以及幻影数据。
      （2）这种使用方式造成了读取的冲突：
          a、设置了共享锁，则无法加专用锁。既读取操作阻塞了写操作；
          b、设置了专用锁，则无法加共享锁。既写操作阻塞了读取操作。
      （3）死锁
        如果有两个会话，每个会话都持有另一个会话想要的资源，就会出现死锁(deadlock)。
      （4）争用
        目前大多数数据库使用锁系统对数据的完整性进行保护。
          a、当请求读取数据时，使用了共享锁；
          b、当写数据时，使用了专用锁。
    10、Oracle的解决方案-事务隔离级别
      SQL标准定义了4种事务隔离级别，对于相同的事务，采用不同的隔离级别分别有不同的结果。
      （1）隔离级别根据3个现象定义：
          脏读(dirty read)：读取了未提交的数据；如果允许脏读将影响数据完整性、破坏外键约束，而且会忽略唯一性约束；
          不可重复读(non-repeatable read)
          幻象读(phantom read)：已经读取的数据不会改变，只是可能会有更多的数据。
      （2）Oracle三个隔离级别：Read Committed、Serializable和read only。Oracle可以为一个事务单独指定一个隔离级别。
      （3）Oracle设置隔离级别的语句
        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
        SET TRANSACTION READ ONLY;
        
        ALTER SESSION SET ISOLATION_LEVEL SERIALIZABLE;
        ALTER SESSION SET ISOLATION_LEVEL READ COMMITTED;
      （4）READ COMMITTED
        “提交读”隔离级别是指事务只能读取数据库中已经提交的数据。这里没有脏读，但是有：
          a、不可重复读：在同一个事务中重新读取同一行可能返回不同的答案；
          b、幻象读：查询不光能看到已经提交的行，还可以看到新插入的行。
        “提交读”在数据库中是最常用的隔离级别，也是oracle数据库的默认模式。
        在oracle中，由于使用多版本和读一致查询，无论使用未提交读还是提交读，查询得到的答案总是一样的。
      （5）REPEATABLE READ
        目标：不仅能够给出一致的正确答案，还能避免丢失更新。
      （6）SERIALIZABLE
        最受限制的隔离级别，但提供了最高程度的隔离性；
        Serializable隔离级别中的事务，在一个环境中操作时，就好像没有别的用户在修改数据库中的数据一样；
        读取的所有行在重新读取时都肯定一样，所执行的查询在整个事务期间也总能返回相同的结果。
        完全消除了“脏读”、不可重复读和幻象读现象。
        查询获得的结果并非相对于语句开始的那个时间点一致，而是在事务开始的那一刻就规定。
      （7）READ ONLY
        Read only事务与serializable事务相似，惟一的区别是read only事务不允许修改，因此不会遭遇ora-08177错误。
        Read only事务的目的是支持报告需求，即相对于某个时间点，报告的内容应该是一致的。








        








          







