索引是应用设计的一个重要方面，太多的索引，DML的性能就会受到影响，如果索引太少，又会影响查询的性能。要找到一个平衡点。

一、索引概述
  B*树索引：传统索引，所有数据库最常用的索引。类似于二叉树，能根据键提供一行或一个行集的快速访问，通常只需很少的读操作就能找到正确的行。
  位图索引：在一颗B*树中，通常索引条目和行之间存在一种一对一的关系，而对于位图索引，一个索引条目则使用一个位图同时指向多行，位图索引适用于高度重复而且通常只读的数据。
二、B*树索引
  叶子节点：B*树最底层的块成为叶子节点或叶子块，其中分别包含各个索引键以及一个rowid（指向所索引的行）；
  分支块：叶子节点之上的内部块称为分支块，这些节点用于在结构中实现导航。
  注意：索引的叶子节点实际上构成了一个双向链表。一旦发现要从叶子节点中的哪里开始，执行值的有序扫描（即索引的区间扫描）就会很容易。
  B*树的特点之一是：所有叶子块都应该在树的同一层上。这一层也称为索引的高度。说明所有从索引的根块到叶子块的遍历都会访问同样数目的块。
  索引是高度平衡的。大多数B*树索引的高度都是2或者3，即使索引中有百万行记录也是如此。
  
  1、索引键压缩
    压缩键索引的基本概念是，每个键条目分解为两部分，前缀和后缀。
  2、索引和表的存储机制
    索引按照索引键的顺序存储，索引会按键的有序顺序进行访问。
    索引指向的块则随机地存储在堆中，因此通过索引访问表时，会执行大量分散、随机的I/O。这种I/O可能很慢。
    索引的此种存储机制决定了索引的两种使用情况。记住，有索引并不代表更快的相应速度。
三、位图索引
  位图索引是这样一种结构，其中用一个索引键条目存储指向多行的指针；与B*树结构不同。在位图索引中，可能只有很少的索引条目，每个索引条目指向多行。
  Oracle为每个键值存储位图，使得每个位置表示底层表中的1个rowid，以后如果确实需要访问行时，可以利用rowid处理。
  这个例子应该使用位图索引:
  create bitmap index gender_idx on t(gender);
  create bitmap index location_idx on t(location);
  create bitmap index age_group_idx on t(age_group);
  exec dbms_stats.gather_table_stats( user, 'T', cascade=>true );

  select count(*)  from T
  where gender = 'M'   and location in ( 1, 10, 30 )
    and age_group = '41 and over';

  select *  from t
  where (   ( gender = 'M' and location = 20 )
        or ( gender = 'F' and location = 22 )) and age_group = '18 and under';
  在数据仓库或支持即席查询的大型报告系统中，能同时合理地使用尽可能多的索引确实非常有用。
  位图索引在读密集的环境中能很好地工作，但在写密集的环境则不行。
四、位图联结索引
  通常索引都是在一个表上创建索引，而且只使用这个表的列。位图联结索引允许使用另外某个表的列对一个给定表建立索引。实际上，这就允许对一个索引结构（而不是表本身）中的数据进行逆规范化。
  这是一个全新的概念：能从其他表对某个表的属性建立索引，而这可能会改变应用中实现数据模型的方式。
  位图联结索引确实有一个先决条件，必须联结到另外一个表中的主键或唯一键，否则会出现错误提示。
  位图索引增加很容易，而且通常比B*树索引快得多。
  如果是一个很大的环境，主要是只读操作，并且有大量即席查询，应用所需的可能正是一组位图索引。
五、基于函数的索引
  利用基于函数的索引，能够对计算得出的列建立索引，并且在查询中使用这些索引。
  1、使用基于函数的索引的主要原因：
    容易实现，并能立即提交一个值；
    可以加快现有应用的速度，而不用修改任何逻辑或查询。





  

    

 
  
